Activities: The internship was data analysis internship under the supervision of Dr. Mervat and TA Nada Labib. I was responsible for graph analysis (supply chain analysis). In the internship, we used neo4j software which is an open-source, NoSQL, native graph database that provides an ACID-compliant transactional backend for your applications. We also used python as programming language and mainly worked with its library pandas. I worked in 2 tasks. The first task was finding all paths from source node to target node. The other task was finding the critical nodes in the supply chain. I participated in this internship remotely. Every day, I started at 10 PM, joining a Google meeting with my colleagues and ended the day at 4 PM. Throughout the day, I worked in pairs with my colleague Rawan in the tasks. And TA Nada checks what we done throughout the day at the end of the day.  A. Week1: a. Tasks Done: i. converted some methods [pk_finder, fk_finder, fkandrefinSetter, primaryKeyGetter, foreignKeyGetter]from the notebook to script  1. Note: Note: these methods were already implemented by my colleagues. The only thing that I did was to convert them to methods and insert them in script instead of notebook ii. Searched for algorithms that will be used in the task which is finding paths from nodes to other nodes. The following cases are the ones that should be handled  [supplier to supplier][customer to supplier][retailer to supplier][supplier to warehouses][supplier to customer][retailer to customer][customer to retailer] iii. Started to implement the algorithms b. Summary of week1: In this week, I started searching for the best fit algorithm that should be used in the whole task. So, I found that Dijkstra's algorithm is the best fit. Dijkstra's algorithm is the one that is used to find the paths. Neo4j offer versions from this algorithm. I used 3 versions in this task which are  - Dijkstra Single-Source Shortest Path which takes a node and return paths to all reachable nodes - Dijkstra Source-Target Shortest Path which takes source node and target node and returns the shortest path  [least cost]  - Yen’s algorithm Shortest Path which takes source and target nodes and the n ,number of paths that you need them, and return the n shortest paths  I divided the cases that should be handles into 2 categories  - The paths that goes with the flows of the graph: [supplier  supplier] [supplier  warehouse][supplier customer][retailer customer] - The Vise Verse Paths: [customer][supplier][retailersupplier][customerretailer] While starting to implement, I found that there are a methods that should is needed to implement the algorithms. These methods are - saveGraph() – which saves the graph after the drawing part - ExistingGraph() – which checks if the graph already exists in the database of not   I also edited the implemented draw graph method in order to fit the new updates Our main searching reference was neo4j documentation. B. Week2: a. Tasks Done: i. Implemented find all paths method [direct relations only] ii. Brainstormed how to validate the path, which criteria should be followed  b. Summary:  In this week, I started implemented find all paths method. In this method, I send neo4j commands to the neo4j and it sends back the paths in form of neo4j.result object. So I convert this object to data frame which contains [sourceNodeName, targetNodeName, totalCost, costs, and nodeNames].  findAllPaths() runs more than one case  1-  Case 0 which runs dijkstra algorithm and returns all paths from the source to all reachable nodes 2- Case 1 which runs yen algorithm and returns at least one path from the source to the target 3- Case 2 which runs dijkstra algorithm and returns only one path from the source to the target In this task, there are challenged and errors faced me in this task  1- The conversion from neo4j.result to data frame 2- Sending the commands from python to neo4j. This part had some errors because the commands sent should be identical to those which ran in neo4j itself C. Week3: a. Tasks Done: i. Implemented methods that validate the direct paths ii. Brainstormed how to implement the method that get the indirect paths b. Summary of week3:               In this week, I implemented validatePath() which validates the paths. This method calls 3 methods which are 1. targetNodeValidation() which delete the invalid rows with invalid target nodes.  2. pathsValidation() which validates the paths and classify them as direct or indirect paths 1- Note: the direct/indirect here based on if the source is connected directly to the target node or there are nodes in the middle 3. lastCheckOnPath() which filter the nodes based on the desired types. For example if the supplier wants to reach another supplier that supply specific type of product. This method is called if the desired type is given as an input to validate path. So it validates the path based on the desired type.  D. Week4: a. Tasks Done: i. Implemented the method which find all Vise Verse paths  ii. Integrate all these methods in one method  b. Summary of Week4: In this week, we implemented findAllPathsViseVerse() which operate the same as find all paths method except some changes in the path in order to call findAllPaths(). Then we integrated all these methods in one method (mainMethod()) . In this week, I also finalized this task and talked with TA Nada about the Task2 which is the critical Nodes Tasks E. Week5: a. Tasks Done: i. Brainstormed what criteria should the critical nodes chosen by ii. Implement 2 criteria from the list we agreed on (me, my colleague “Rawan”, TA Nada) b. Summary of Week 5: In this week, we started in task 2 which is identifying the critical nodes in the supply chain for example the only supplier, Retailer, or warehouse in specific location. So I started by implementing the first criteria which is the location. I created another class called CriticalNodeTask.py and implemented the first 2 criteria we agreed on. The first method was getCriticalNodesRespectToLocation() which get the supplier, Retailer, and warehouse that are the only ones in their locations and added them to the critical nodes list. This method used another methods called getUniqueLocations() and getLocationFromAttributes() which I implemented as helper methods. The second method implemented was criticalNodesRespectToProduct() which get the only supply, retailer, warehouse that supply or sell or has the product. Please refer to the last 2 pages to check screenshots of some of the result output from the 2 tasks. The first 3 screenshots are the outputs from the 1st task [output of neo4j that converted to data frames in python]. The last 2 screenshots from the 2nd task  3- Evaluation of the internship: I gained from this internship some skills which are time management, project management, leadership, and problem-solving. I also learned new concepts which are data analysis concepts, and graph analysis algorithms. I also learned more about the pandas library in python. Yes, the internship was above my expectations. I wasn’t expecting that it will help me like this. Besides the skills and concepts learned, it also gave me more confidence in working with python. The internship also influenced me to explore more the data analysis field in order to work in it in the future. The internship helped me this semester (9th semester) since I am taking Data Engineering, and in this course, we work with the same python library in the internship, so it made the course easier. This internship is more related to the data engineering course that I’m taking this year as an elective. I totally recommend this organization to GUC students.   4- Conclusion:  To conclude, I’m really pleased that I worked in this internship under Dr. Mervat and TA Nada supervision and with my colleagues. I learned a lot of skills technical and non-technical. The internship also helped me developing myself and expanding more my future career. It also helped me expand my knowledge in python and in graph analysis algorithms. As I mentioned, the internship was mainly data analysis internship. I worked in 2 tasks which are finding the paths between nodes in the supply chain and finding the critical nodes in the supply chain. We used in this internship python as programming language and also used neo4j software. I totally recommend this organization to my GUC colleagues.                                               