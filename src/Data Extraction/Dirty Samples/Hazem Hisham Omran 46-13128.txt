ActivitiesThe internship at Crossworkers was a full-time hybrid internship where I worked 8 hours a dayand went to the office twice a week. The day typically started with a daily standup meeting withthe client in the morning where each of the team members mentioned what they did the previousday and what they would do today. I worked as a back-end intern in a team of four othermembers and reported directly to the senior back-end of the team. I also worked hand in handwith the other three members who worked as front-end developers to combine our work witheach other.Throughout my internship, I used different software applications and frameworks. Coding wasdone on the Visual Studio Code IDE using Node.js, Typescript, and TypeORM for databases. Ialso worked with RabbitMQ for message queues and AWS S3 for cloud storage. Moreover, Iused DBeaver to visualize the database, the data inside the different tables, and the relationsbetween the tables. For validation, I used the JOI framework. We also used Slack and MicrosoftTeams for communicating and ClickUp for assigning tasks, writing descriptions, and markingprogress. For source control, we used Gitlab to ease versioning and pipeline written tests.Figure 2: Example of the visualization of relationships DBeaver offers. [2]Figure 3: Example of the task organization on ClickUp. [3]For my first task, I was responsible for migrating the codebase from using SQL to TypeORM. Idid this by going through all the parts in the code where SQL statements were used, and thenexecuted those SQL statements on DBeaver and recorded the output. Next, I converted thoseSQL statements to TypeORM then once again tested the new TypeORM implementation onDBeaver to make sure the previous and current results match. This was a good task to start withas it helped me learn both Typescript and TypeORM and get a grasp of the codebase. For thesecond task, I was asked to design several entities using TypeORM and to write correspondingAPI for them with validation using JOI. Together with the first task, this task allowed me to gothrough most of the TypeORM documentation and get a firm grasp of the framework. This taskrequired a lot of close communication with the frontend team in order to properly design theAPI’s. For the third task, I used AWS S3 with the help of the Multer-S3 [4] library in order todesign API’s that would store and retrieve pictures from different sources. I then tested myimplementation by uploading and retrieving images through the API’s that I designed andchecking whether the API resonated on the AWS website or not. For my fourth task, I wrote unitand integration tests for API’s that I developed and for already existing API’s and functionsusing the JEST framework. This was an interesting task as it exposed me to Test DrivenDevelopment, a software development process that depends on writing tests first before code,and its benefits, as I ended up changing parts of the code I wrote only to ease the writing of tests.For my fifth task, we had sensors which we needed to communicate with and process the datathey sent us. For that, I made a message queue using RabbitMQ to allow us to retrieve the datafrom the different sensors and then process them while guaranteeing that the data would not belost in case the server or the database fails. This task taught me a lot as it was somewhat gearedtowards DevOps and required extensive research to understand how message queues worked andhow they were implemented through code. I was also able to suggest using various queue typesand displayed their advantages and disadvantages to the client so they could choose the one theypreferred the most.Figure 4: General diagram for Message Queue ImplementationFigure 5: Flowchart showing brief flow of the message queue processMoreover, I was tasked with refactoring some code in order to make it more efficient. Thisresonated with the CS3 course that I had taken in college. For my seventh task, I was asked toapply the same linting rules to all of the different repositories we had. To do so, I made an npmpackage and installed it on all our different repositories. By doing that, we were able to centralizechanging the lint rules and easily apply them to all our codebases. This task taught me how tocreate npm libraries and maintain them. On the eighth task, I changed the codebase to a modulebased codebase so that it’s easier to navigate around the files and maintain it in the future.Finally, for my last task, I was told to investigate why users’ sessions were short and they wouldneed to re-log in every short period of time. This was a challenging task as it required debugginga big chunk of the codebase but I was able to pinpoint and resolve the issue in the end, whichwas related to incorrect use of refresh tokens.Figure 6: Diagram showing flow and importance of refresh tokens.Internship 